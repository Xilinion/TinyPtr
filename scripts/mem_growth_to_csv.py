import os
import re
import csv
import math
from typing import List, Tuple

# Expect config_py.py to be generated by scripts/to_csv.sh
try:
    import config_py  # type: ignore
except Exception as e:
    raise SystemExit("config_py.py not found. Run scripts/to_csv.sh first to generate it.")


def parse_memuse_file(path: str) -> Tuple[List[float], List[float], List[float]]:
    """Parse a memuse file and return lists of times, real (MB), virtual (MB)."""
    times: List[float] = []
    reals: List[float] = []
    virtuals: List[float] = []

    with open(path, "r") as f:
        for line in f:
            if not line.strip() or line.lstrip().startswith("#"):
                continue
            # Format: Elapsed CPU Real Virtual
            parts = line.split()
            if len(parts) < 4:
                continue
            try:
                t = float(parts[0])
                real = float(parts[2])
                virt = float(parts[3])
            except ValueError:
                continue
            times.append(t)
            reals.append(real)
            virtuals.append(virt)

    return times, reals, virtuals


def find_object_id(filename: str) -> int:
    m = re.search(r"object_(\d+)_case_(\d+)_entry_(\d+)_memuse\\.txt", filename)
    if not m:
        raise ValueError(f"Filename not recognized: {filename}")
    return int(m.group(1))


def remove_trailing_zeros(times: List[float], mem: List[float]) -> Tuple[List[float], List[float]]:
    """Remove trailing zero values from the end of the memory series."""
    if not mem:
        return times, mem
    
    # Find last non-zero index
    last_nonzero = len(mem) - 1
    for i in range(len(mem) - 1, -1, -1):
        if mem[i] != 0.0:
            last_nonzero = i
            break
    
    # If all zeros, return empty
    if last_nonzero < 0 or mem[last_nonzero] == 0.0:
        return [], []
    
    return times[:last_nonzero + 1], mem[:last_nonzero + 1]


def normalized_series(times: List[float], mem: List[float], use_peak_as_end: bool = True) -> Tuple[List[float], List[float]]:
    """Cut series from first change to either peak or final point, then normalize time to [0,1].
    
    Args:
        times: List of time values
        mem: List of memory values
        use_peak_as_end: If True, cut to last occurrence of peak memory value.
                        If False, cut to final data point.
    """
    if not times:
        return [], []

    # Remove trailing zeros first
    times, mem = remove_trailing_zeros(times, mem)
    if not times:
        return [], []

    t0 = times[0]
    # Detect first change from initial memory (use virtual by default upstream)
    start_idx = 0
    for i in range(1, len(mem)):
        if mem[i] != mem[0]:
            start_idx = i
            break
    
    # Determine end index based on mode
    if use_peak_as_end:
        # Peak index (greatest memory usage) - use LAST occurrence if multiple peaks
        peak_mem = max(mem)
        end_idx = start_idx  # default fallback
        for i in range(len(mem) - 1, -1, -1):  # search backwards from end
            if mem[i] == peak_mem:
                end_idx = i
                break
    else:
        # Use final data point
        end_idx = len(mem) - 1
    
    if end_idx < start_idx:
        # Fallback: ensure non-empty slice
        start_idx, end_idx = 0, max(0, end_idx)

    cut_times = times[start_idx : end_idx + 1]
    cut_mem = mem[start_idx : end_idx + 1]
    if not cut_times:
        return [], []

    t_start = cut_times[0]
    t_end = cut_times[-1]
    span = max(1e-9, (t_end - t_start))
    norm_times = [(t - t_start) / span for t in cut_times]
    return norm_times, cut_mem


def resample_50(norm_times: List[float], mem: List[float]) -> List[Tuple[float, float]]:
    """Return 50 evenly spaced points in [0,1] using nearest neighbor in time."""
    if not norm_times:
        return []
    targets = [i / 49.0 for i in range(50)]
    out: List[Tuple[float, float]] = []
    j = 0
    for x in targets:
        # advance j while closer to next point
        while j + 1 < len(norm_times) and abs(norm_times[j + 1] - x) <= abs(norm_times[j] - x):
            j += 1
        out.append((x, mem[j]))
    return out


def main() -> None:
    # ============ CONFIGURATION ============
    # Set to True to cut series at last occurrence of peak memory
    # Set to False to cut series at final data point
    USE_PEAK_AS_END = False
    # =======================================
    
    base_dir = config_py.RESULTS_DIR
    out_dir = config_py.CSV_OUTPUT_DIR
    os.makedirs(out_dir, exist_ok=True)

    # Use resize settings from scripts/benchmark.sh
    # resize_object_ids=(6 7 15 18 21 24), case_id=1, entry_id=10000
    object_ids = [6, 7, 15, 18, 21, 24]
    case_id = 1
    entry_id = 10000

    rows_written = 0
    output_csv = os.path.join(out_dir, "mem_growth.csv")
    with open(output_csv, "w", newline="") as f:
        w = csv.writer(f)
        w.writerow(["object_id", "normalized_time", "memory_mb"])  # memory_mb uses Virtual (MB)

        for obj in object_ids:
            file_name = f"object_{obj}_case_{case_id}_entry_{entry_id}_memuse.txt"
            path = os.path.join(base_dir, file_name)
            if not os.path.exists(path):
                print(f"Warning: missing {file_name}")
                continue

            times, reals, virtuals = parse_memuse_file(path)
            if not times:
                print(f"Warning: no parsable lines in {file_name}")
                continue

            norm_times, mem_series = normalized_series(times, virtuals, use_peak_as_end=USE_PEAK_AS_END)
            if not norm_times:
                print(f"Warning: no usable segment (no change->peak) in {file_name}")
                continue

            samples = resample_50(norm_times, mem_series)
            if not samples:
                print(f"Warning: resampling produced no points for object {obj}")
                continue

            for nt, mem in samples:
                w.writerow([obj, f"{nt:.6f}", f"{mem:.6f}"])
                rows_written += 1

    if rows_written == 0:
        print("Warning: mem_growth.csv contains no data rows. Verify benchmark.sh and results directory.")
    print(f"Created {output_csv} (USE_PEAK_AS_END={USE_PEAK_AS_END})")


if __name__ == "__main__":
    main()


